diff --git a/port/stm32-f4discovery-nrf5340/Drivers/BSP/STM32F4-Discovery/stm32f4_discovery_audio.c b/port/stm32-f4discovery-nrf5340/Drivers/BSP/STM32F4-Discovery/stm32f4_discovery_audio.c
index 6f1814308..915fa96f6 100644
--- a/port/stm32-f4discovery-nrf5340/Drivers/BSP/STM32F4-Discovery/stm32f4_discovery_audio.c
+++ b/port/stm32-f4discovery-nrf5340/Drivers/BSP/STM32F4-Discovery/stm32f4_discovery_audio.c
@@ -113,6 +113,7 @@ b) RECORD A FILE:
 
 /* Includes ------------------------------------------------------------------*/
 #include "stm32f4_discovery_audio.h"
+#include "hal_audio.h"
 
 /** @addtogroup BSP
   * @{
@@ -138,10 +139,53 @@ b) RECORD A FILE:
 /** @defgroup STM32F4_DISCOVERY_AUDIO_Private_Defines STM32F4 DISCOVERY AUDIO Private Defines
   * @{
   */ 
-/* These PLL parameters are valid when the f(VCO clock) = 1Mhz */
-const uint32_t I2SFreq[8] = {8000, 11025, 16000, 22050, 32000, 44100, 48000, 96000};
-const uint32_t I2SPLLN[8] = {256, 429, 213, 429, 426, 271, 258, 344};
-const uint32_t I2SPLLR[8] = {5, 4, 4, 4, 4, 6, 3, 1};
+static uint32_t bsp_audio_out_actual_frequency = 0;
+static uint32_t bsp_audio_out_frequency = 0;
+
+typedef struct {
+    uint32_t freq;
+    uint32_t actual;
+    uint16_t r;
+    uint16_t n;
+} i2s_pll_entry_t;
+
+// HSE_VALUE = 8000000
+// PLLM = 4
+// MCK on
+static const i2s_pll_entry_t i2s_pll_table[] = {
+    {  8000,  8000, 5, 128 }, /* i2sdiv:  12, odd: 1, rate error % (desired vs actual)%: 0.0000 */
+    { 11025, 11024, 2, 127 }, /* i2sdiv:  22, odd: 1, rate error % (desired vs actual)%: 0.0063 */
+    { 12000, 12000, 5, 192 }, /* i2sdiv:  12, odd: 1, rate error % (desired vs actual)%: 0.0000 */
+    { 16000, 16000, 4, 213 }, /* i2sdiv:  13, odd: 0, rate error % (desired vs actual)%: 0.0038 */
+    { 22050, 22048, 5, 127 }, /* i2sdiv:   4, odd: 1, rate error % (desired vs actual)%: 0.0063 */
+    { 24000, 24003, 3, 212 }, /* i2sdiv:  11, odd: 1, rate error % (desired vs actual)%: 0.0151 */
+    { 32000, 32001, 4, 213 }, /* i2sdiv:   6, odd: 1, rate error % (desired vs actual)%: 0.0038 */
+    { 44100, 44084, 2,  79 }, /* i2sdiv:   3, odd: 1, rate error % (desired vs actual)%: 0.0344 */
+    { 48000, 47991, 2,  86 }, /* i2sdiv:   3, odd: 1, rate error % (desired vs actual)%: 0.0186 */
+    { 96000, 95982, 2, 172 }, /* i2sdiv:   3, odd: 1, rate error % (desired vs actual)%: 0.0186 */
+};
+
+#define BARRIER do { __asm__ volatile("" ::: "memory"); } while (0)
+#define BINARY(I) do {                                            \
+                base = ((base)[I].freq <= frequency)?base+I:base; \
+                BARRIER;                                          \
+        } while (0)
+
+/** @brief  Searches I2S PLL parameter giving highest frequency accuracy possible
+  * @param  frequency: the frequency to seach PLL parameter for
+  * @retval The PLL config with helps setting specified frequency
+  * @note   This assembles a unrolled binary search for a fixed table size,
+  *         so changes to the table size need to be reflected here. Or should
+  *         be auto-generated
+  */
+static i2s_pll_entry_t const *i2s_find_pll_params( uint32_t frequency ) {
+    i2s_pll_entry_t const* base = i2s_pll_table;
+    BINARY(5);
+    BINARY(2);
+    BINARY(1);
+    BINARY(1);
+    return base;
+}
 /**
   * @}
   */ 
@@ -255,6 +299,7 @@ uint8_t BSP_AUDIO_OUT_Play(uint16_t* pBuffer, uint32_t Size)
   }
   else 
   {
+    bsp_audio_out_frequency = bsp_audio_out_actual_frequency;
     /* Update the Media layer and enable it for play */  
     HAL_I2S_Transmit_DMA(&hAudioOutI2s, pBuffer, DMA_MAX(Size/AUDIODATA_SIZE)); 
     
@@ -334,6 +379,8 @@ uint8_t BSP_AUDIO_OUT_Stop(uint32_t Option)
   /* Call DMA Stop to disable DMA stream before stopping codec */
   HAL_I2S_DMAStop(&hAudioOutI2s);
   
+  bsp_audio_out_frequency = 0;
+
   /* Call Audio Codec Stop function */
   if(pAudioDrv->Stop(AUDIO_I2C_ADDRESS, Option) != 0)
   {
@@ -470,38 +517,21 @@ void HAL_I2S_TxHalfCpltCallback(I2S_HandleTypeDef *hi2s)
 __weak void BSP_AUDIO_OUT_ClockConfig(I2S_HandleTypeDef *hi2s, uint32_t AudioFreq, void *Params)
 { 
   RCC_PeriphCLKInitTypeDef rccclkinit;
-  uint8_t index = 0, freqindex = 0xFF;
   
-  for(index = 0; index < 8; index++)
-  {
-    if(I2SFreq[index] == AudioFreq)
-    {
-      freqindex = index;
-    }
-  }
+  i2s_pll_entry_t const *pll_params = i2s_find_pll_params( AudioFreq );
+
+  bsp_audio_out_actual_frequency = pll_params->actual;
   /* Enable PLLI2S clock */
   HAL_RCCEx_GetPeriphCLKConfig(&rccclkinit);
-  /* PLLI2S_VCO Input = HSE_VALUE/PLL_M = 1 Mhz */
-  if ((freqindex & 0x7) == 0)
-  {
-    /* I2S clock config 
-    PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) × (PLLI2SN/PLLM)
-    I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
-    rccclkinit.PeriphClockSelection = RCC_PERIPHCLK_I2S;
-    rccclkinit.PLLI2S.PLLI2SN = I2SPLLN[freqindex];
-    rccclkinit.PLLI2S.PLLI2SR = I2SPLLR[freqindex];
-    HAL_RCCEx_PeriphCLKConfig(&rccclkinit);
-  }
-  else 
-  {
-    /* I2S clock config 
-    PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) × (PLLI2SN/PLLM)
-    I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
-    rccclkinit.PeriphClockSelection = RCC_PERIPHCLK_I2S;
-    rccclkinit.PLLI2S.PLLI2SN = 258;
-    rccclkinit.PLLI2S.PLLI2SR = 3;
-    HAL_RCCEx_PeriphCLKConfig(&rccclkinit);
-  }
+  /* PLLI2S_VCO Input = HSE_VALUE/PLL_M */
+
+  /* I2S clock config
+  PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLM)
+  I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
+  rccclkinit.PeriphClockSelection = RCC_PERIPHCLK_I2S;
+  rccclkinit.PLLI2S.PLLI2SN = pll_params->n;
+  rccclkinit.PLLI2S.PLLI2SR = pll_params->r;
+  HAL_RCCEx_PeriphCLKConfig(&rccclkinit);
 }
 
 /**
@@ -551,6 +581,13 @@ __weak void BSP_AUDIO_OUT_MspInit(I2S_HandleTypeDef *hi2s, void *Params)
     hdma_i2sTx.Init.PeriphDataAlignment = I2S3_DMAx_PERIPH_DATA_SIZE;
     hdma_i2sTx.Init.MemDataAlignment    = I2S3_DMAx_MEM_DATA_SIZE;
     hdma_i2sTx.Init.Mode                = DMA_NORMAL;
+
+    // BK: use circular DMA for hal_audio.h
+#ifdef HAVE_HAL_AUDIO
+    hdma_i2sTx.Init.Mode                = DMA_CIRCULAR;
+#endif
+    // BK: use circular DMA (end)
+
     hdma_i2sTx.Init.Priority            = DMA_PRIORITY_HIGH;
     hdma_i2sTx.Init.FIFOMode            = DMA_FIFOMODE_ENABLE;         
     hdma_i2sTx.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
@@ -688,13 +725,17 @@ static uint8_t I2S3_Init(uint32_t AudioFreq)
 uint8_t BSP_AUDIO_IN_Init(uint32_t AudioFreq, uint32_t BitRes, uint32_t ChnlNbr)
 {
   
+#if 0
+  // BK: only do PLL clock configuration in sink
   /* Configure PLL clock */ 
   BSP_AUDIO_IN_ClockConfig(&hAudioInI2s, AudioFreq, NULL);
+#endif
   
   /* Configure the PDM library */
   /* On STM32F4-Discovery a single microphone is mounted, samples are duplicated
      to make stereo audio streams */
-  PDMDecoder_Init(AudioFreq, ChnlNbr, 2);
+  // BK - generate mono output
+  PDMDecoder_Init(AudioFreq, ChnlNbr, 1);
 
   /* Configure the I2S peripheral */
   hAudioInI2s.Instance = I2S2;
@@ -810,11 +851,15 @@ uint8_t BSP_AUDIO_IN_PDMToPCM(uint16_t *PDMBuf, uint16_t *PCMBuf)
     /* PDM to PCM filter */
 	PDM_Filter((uint8_t*)&AppPDM[index], (uint16_t*)&(PCMBuf[index]), &PDM_FilterHandler[index]);
   }
+#if 0
+  // BK - generate mono output
+
   /* Duplicate samples since a single microphone in mounted on STM32F4-Discovery */
   for(index = 0; index < PCM_OUT_SIZE; index++)
   {
     PCMBuf[(index<<1)+1] = PCMBuf[index<<1];
   }
+#endif
   
   /* Return AUDIO_OK when all operations are correctly done */
   return AUDIO_OK; 
@@ -841,6 +886,17 @@ void HAL_I2S_RxHalfCpltCallback(I2S_HandleTypeDef *hi2s)
   BSP_AUDIO_IN_HalfTransfer_CallBack();
 }
 
+/**
+  * @brief  Retrive the audio frequency.
+  * @retval AudioFreq: Audio frequency used to play the audio stream.
+  * @note   This API should be called after the BSP_AUDIO_OUT_Init() to adjust the
+  *         audio frequency.
+  */
+uint32_t hal_audio_sink_get_frequency(void)
+{
+  return bsp_audio_out_frequency;
+}
+
 /**
   * @brief  Audio In Clock Config.
   * @param  hi2s: I2S handle
@@ -855,27 +911,11 @@ __weak void BSP_AUDIO_IN_ClockConfig(I2S_HandleTypeDef *hi2s, uint32_t AudioFreq
 
   /*Enable PLLI2S clock*/
   HAL_RCCEx_GetPeriphCLKConfig(&rccclkinit);
-  /* PLLI2S_VCO Input = HSE_VALUE/PLL_M = 1 Mhz */
-  if ((AudioFreq & 0x7) == 0)
-  {
-    /* Audio frequency multiple of 8 (8/16/32/48/96/192)*/
-    /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN = 192 Mhz */
-    /* I2SCLK = PLLI2S_VCO Output/PLLI2SR = 192/6 = 32 Mhz */
-    rccclkinit.PeriphClockSelection = RCC_PERIPHCLK_I2S;
-    rccclkinit.PLLI2S.PLLI2SN = 192;
-    rccclkinit.PLLI2S.PLLI2SR = 6;
-    HAL_RCCEx_PeriphCLKConfig(&rccclkinit);
-  }
-  else
-  {
-    /* Other Frequency (11.025/22.500/44.100) */
-    /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN = 290 Mhz */
-    /* I2SCLK = PLLI2S_VCO Output/PLLI2SR = 290/2 = 145 Mhz */
-    rccclkinit.PeriphClockSelection = RCC_PERIPHCLK_I2S;
-    rccclkinit.PLLI2S.PLLI2SN = 290;
-    rccclkinit.PLLI2S.PLLI2SR = 2;
-    HAL_RCCEx_PeriphCLKConfig(&rccclkinit);
-  }
+  i2s_pll_entry_t const *pll_params = i2s_find_pll_params( AudioFreq );
+  rccclkinit.PeriphClockSelection = RCC_PERIPHCLK_I2S;
+  rccclkinit.PLLI2S.PLLI2SN = pll_params->n;
+  rccclkinit.PLLI2S.PLLI2SR = pll_params->r;
+  HAL_RCCEx_PeriphCLKConfig(&rccclkinit);
 }
 
 /**
